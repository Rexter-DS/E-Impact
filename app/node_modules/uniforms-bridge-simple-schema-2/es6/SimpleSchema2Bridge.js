import { __rest } from "tslib";
import invariant from 'invariant';
import cloneDeep from 'lodash/cloneDeep';
import memoize from 'lodash/memoize';
import SimpleSchema from 'simpl-schema';
import { Bridge, joinName } from 'uniforms';
export default class SimpleSchema2Bridge extends Bridge {
    constructor(schema) {
        super();
        this.schema = schema;
        // Memoize for performance and referential equality.
        this.getField = memoize(this.getField);
        this.getSubfields = memoize(this.getSubfields);
        this.getType = memoize(this.getType);
    }
    getError(name, error) {
        var _a, _b;
        // FIXME: Correct type for `error`.
        return ((_b = (_a = error === null || error === void 0 ? void 0 : error.details) === null || _a === void 0 ? void 0 : _a.find) === null || _b === void 0 ? void 0 : _b.call(_a, (error) => error.name === name)) || null;
    }
    getErrorMessage(name, error) {
        const scopedError = this.getError(name, error);
        // @ts-ignore: `messageForError` has incorrect typing.
        return !scopedError ? '' : this.schema.messageForError(scopedError);
    }
    getErrorMessages(error) {
        if (error) {
            if (Array.isArray(error.details)) {
                // FIXME: Correct type for `error`.
                return error.details.map(error => 
                // @ts-ignore: `messageForError` has incorrect typing.
                this.schema.messageForError(error));
            }
            if (error.message) {
                return [error.message];
            }
        }
        if (error !== undefined) {
            return [error];
        }
        return [];
    }
    getField(name) {
        const definition = this.schema.getDefinition(name);
        invariant(definition, 'Field not found in schema: "%s"', name);
        const merged = Object.assign(Object.assign({}, definition), definition.type[0]);
        // aldeed/node-simple-schema#27
        if (merged.autoValue &&
            (merged.autoValue.name === 'defaultAutoValueFunction' ||
                merged.autoValue.toString().indexOf('$setOnInsert:') !== -1) // FIXME: Hack.
        ) {
            try {
                merged.defaultValue = merged.autoValue.call({ operator: null });
            }
            catch (_) {
                /* ignore it */
            }
        }
        return merged;
    }
    getInitialValue(name, props = {}) {
        const field = this.getField(name);
        if (field.type === Array) {
            const item = this.getInitialValue(joinName(name, '0'));
            const items = Math.max(props.initialCount || 0, field.minCount || 0);
            return Array.from({ length: items }, () => item);
        }
        if (field.type === Object || field.type instanceof SimpleSchema) {
            return {};
        }
        return field.defaultValue;
    }
    // eslint-disable-next-line complexity
    getProps(name, props = {}) {
        const _a = this.getField(name), { optional, type, uniforms } = _a, contextField = __rest(_a, ["optional", "type", "uniforms"]);
        let field = Object.assign(Object.assign({}, contextField), { required: !optional });
        if (uniforms) {
            if (typeof uniforms === 'string' || typeof uniforms === 'function') {
                field = Object.assign(Object.assign({}, field), { component: uniforms });
            }
            else {
                field = Object.assign(Object.assign({}, field), uniforms);
            }
        }
        if (type === Array) {
            try {
                const itemProps = this.getProps(`${name}.$`, props);
                if (itemProps.allowedValues && !props.allowedValues) {
                    field.allowedValues = itemProps.allowedValues;
                }
                if (itemProps.transform && !props.transform) {
                    field.transform = itemProps.transform;
                }
            }
            catch (_) {
                /* ignore it */
            }
        }
        else if (type === Number) {
            field = Object.assign(Object.assign({}, field), { decimal: true });
        }
        let options = props.options || field.options;
        if (options) {
            if (typeof options === 'function') {
                options = options();
            }
            if (!Array.isArray(options)) {
                field = Object.assign(Object.assign({}, field), { transform: (value) => options[value], allowedValues: Object.keys(options) });
            }
            else {
                field = Object.assign(Object.assign({}, field), { transform: (value) => options.find(option => option.value === value).label, allowedValues: options.map(option => option.value) });
            }
        }
        return field;
    }
    getSubfields(name) {
        // @ts-ignore: Typing for `_makeGeneric` is missing.
        return this.schema.objectKeys(SimpleSchema._makeGeneric(name));
    }
    getType(name) {
        const type = this.getField(name).type;
        if (type === SimpleSchema.Integer) {
            return Number;
        }
        if (type instanceof SimpleSchema) {
            return Object;
        }
        return type;
    }
    // TODO: `ValidationOption` is not exported.
    getValidator(options = { clean: true, mutate: true }) {
        const validator = this.schema.validator(options);
        return (model) => {
            try {
                // Clean mutate its argument, even if mutate is false.
                validator(options.clean ? cloneDeep(Object.assign({}, model)) : model);
                return null;
            }
            catch (error) {
                return error;
            }
        };
    }
}
